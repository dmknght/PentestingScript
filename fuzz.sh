#!/binb/bash
# https://ryanstutorials.net/bash-scripting-tutorial/bash-variables.php
# https://shapeshed.com/unix-exit-codes/
# https://stackoverflow.com/a/5349842


# check script arguments
if [ "$#" != 2 ]; then
	echo "Usage: $0 <program_name> <argv / stdin>"
	exit
fi

program=$1
f_msg=`echo "A" | ./$program`
f_sig="$?"

# If running error, exit
# Fix condition syntax error
# https://stackoverflow.com/a/34070823

if [ "$f_sig" -ge "120" ]; then
	exit
fi

echo "=============================="
echo "Stdout: \"$f_msg\""
echo "SIG: $f_sig"
echo "=============================="
# Get test return signal

for i in {2..4000}; do
	stdin=$(printf '%*s' $i '')

	# Creating progress bar
	# Has display bug because of syntax error
	#stt=($i * 80 / 4000)
	#pstt=$(printf '%*s' $stt '')
	#echo -ne "${pstt// /*} \r" 
	# End of progress bar
	

	if [ "$2" == "stdin" ]; then
		# Push string to stdin using pipe
		output=`echo "${stdin// /*}" | ./$program`

	elif [ "$2" == "argv" ]; then
		# Run program with argument
		output=`./$program \`echo "${stdin// /*}"\``

	else
		echo "Invalid option! Must be \"argv\" or \"stdin\""
		exit
	fi

	sig=$?

	if [ "$sig" != "$f_sig" ]; then
		# If we have new return code
		echo "Recv SIG: $sig at length $i"
		echo "Stdout: \"$output\""

		if [ "$sig" > 128 ]; then
			# Bad return code
			echo "******************************"
			echo "$program has crashed"
			echo "******************************"
		fi
		break

	elif [ "$output" != "$f_msg" ]; then
		# If we have other sdtout
		echo "------------------------------"
		echo "Stdout: \"$output\" at length $i"
		echo "------------------------------"
		f_msg=$output
	fi
	
done

echo "Done --------------------->>>>>"
